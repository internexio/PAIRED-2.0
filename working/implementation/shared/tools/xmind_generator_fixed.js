/**
 * PAIRED XMind Generator - Fixed with Official XMind SDK
 * 
 * Generates proper XMind-compatible files using the official XMind SDK
 * Fixes the file corruption issue by using real XMind ZIP container format
 */

const { Workbook, Topic, Marker, Zipper } = require('xmind');
const path = require('path');
const fs = require('fs').promises;

class XMindGeneratorFixed {
    constructor() {
        this.agentColors = {
            'Sherlock': '#FF6B35',    // Orange - QA Agent
            'Alex': '#4A90E2',        // Blue - PM Agent  
            'Leonardo': '#7B68EE',    // Purple - Architecture Agent
            'Edison': '#32CD32',      // Green - Dev Agent
            'Maya': '#FF69B4',        // Pink - UX Agent
            'Vince': '#FFD700',       // Gold - Scrum Master Agent
            'Marie': '#20B2AA'        // Teal - Analyst Agent
        };
    }

    /**
     * Generate XMind file from structured data using official SDK
     */
    async generateMindMap(options) {
        const {
            title = 'Logic Diagram',
            data = {},
            outputPath = './diagram.xmind',
            agent = 'Leonardo',
            layout = 'hierarchical',
            description = 'Generated by PAIRED Logic Diagram System'
        } = options;

        try {
            // Create workbook and sheet
            const workbook = new Workbook();
            const sheet = workbook.createSheet('Logic Analysis', title);
            
            // Create root topic with agent-specific styling
            const rootTopic = new Topic({ sheet });
            
            // Add description as note to root topic
            if (description) {
                rootTopic.note(description);
            }

            // Process data structure and create topics
            await this.processDataStructure(rootTopic, data, agent);

            // Create zipper for proper XMind file generation
            const outputDir = path.dirname(outputPath);
            const filename = path.basename(outputPath, '.xmind');
            
            const zipper = new Zipper({
                path: outputDir,
                workbook,
                filename
            });

            // Save the XMind file
            const success = await zipper.save();
            
            if (success) {
                console.log(`âœ… XMind file generated: ${outputPath}`);
                return {
                    success: true,
                    outputPath,
                    message: 'XMind file generated successfully with official SDK'
                };
            } else {
                throw new Error('Failed to save XMind file');
            }

        } catch (error) {
            console.error('âŒ XMind generation failed:', error.message);
            return {
                success: false,
                error: error.message,
                message: 'XMind generation failed'
            };
        }
    }

    /**
     * Process data structure and create hierarchical topics
     */
    async processDataStructure(rootTopic, data, agent) {
        if (!data || typeof data !== 'object') {
            return;
        }

        // Handle different data structures
        if (data.decisions && Array.isArray(data.decisions)) {
            await this.createDecisionTree(rootTopic, data.decisions, agent);
        }

        if (data.flows && Array.isArray(data.flows)) {
            await this.createFlowDiagram(rootTopic, data.flows, agent);
        }

        if (data.components && Array.isArray(data.components)) {
            await this.createComponentDiagram(rootTopic, data.components, agent);
        }

        if (data.processes && Array.isArray(data.processes)) {
            await this.createProcessDiagram(rootTopic, data.processes, agent);
        }

        // Handle generic structure
        if (data.items && Array.isArray(data.items)) {
            await this.createGenericStructure(rootTopic, data.items, agent);
        }
    }

    /**
     * Create decision tree structure
     */
    async createDecisionTree(rootTopic, decisions, agent) {
        const decisionBranch = rootTopic.add({ title: 'ðŸ”€ Decision Points' });
        
        decisions.forEach((decision, index) => {
            const decisionTopic = decisionBranch.add({ 
                title: `${decision.condition || `Decision ${index + 1}`}` 
            });
            
            if (decision.description) {
                decisionTopic.note(decision.description);
            }

            // Add branches for true/false outcomes
            if (decision.trueBranch) {
                const trueTopic = decisionTopic.add({ title: 'âœ… True Branch' });
                if (Array.isArray(decision.trueBranch)) {
                    decision.trueBranch.forEach(item => {
                        trueTopic.add({ title: item.title || item });
                    });
                } else {
                    trueTopic.add({ title: decision.trueBranch });
                }
            }

            if (decision.falseBranch) {
                const falseTopic = decisionTopic.add({ title: 'âŒ False Branch' });
                if (Array.isArray(decision.falseBranch)) {
                    decision.falseBranch.forEach(item => {
                        falseTopic.add({ title: item.title || item });
                    });
                } else {
                    falseTopic.add({ title: decision.falseBranch });
                }
            }
        });
    }

    /**
     * Create flow diagram structure
     */
    async createFlowDiagram(rootTopic, flows, agent) {
        const flowBranch = rootTopic.add({ title: 'ðŸ”„ Process Flows' });
        
        flows.forEach((flow, index) => {
            const flowTopic = flowBranch.add({ 
                title: `${flow.name || `Flow ${index + 1}`}` 
            });
            
            if (flow.description) {
                flowTopic.note(flow.description);
            }

            // Add flow steps
            if (flow.steps && Array.isArray(flow.steps)) {
                flow.steps.forEach((step, stepIndex) => {
                    const stepTopic = flowTopic.add({ 
                        title: `${stepIndex + 1}. ${step.title || step}` 
                    });
                    
                    if (step.description) {
                        stepTopic.note(step.description);
                    }
                });
            }
        });
    }

    /**
     * Create component diagram structure
     */
    async createComponentDiagram(rootTopic, components, agent) {
        const componentBranch = rootTopic.add({ title: 'ðŸ—ï¸ Components' });
        
        components.forEach(component => {
            const componentTopic = componentBranch.add({ 
                title: component.name || component.title || 'Component' 
            });
            
            if (component.description) {
                componentTopic.note(component.description);
            }

            // Add component methods/functions
            if (component.methods && Array.isArray(component.methods)) {
                const methodsBranch = componentTopic.add({ title: 'âš™ï¸ Methods' });
                component.methods.forEach(method => {
                    methodsBranch.add({ title: method.name || method });
                });
            }

            // Add component properties
            if (component.properties && Array.isArray(component.properties)) {
                const propsBranch = componentTopic.add({ title: 'ðŸ“‹ Properties' });
                component.properties.forEach(prop => {
                    propsBranch.add({ title: prop.name || prop });
                });
            }
        });
    }

    /**
     * Create process diagram structure
     */
    async createProcessDiagram(rootTopic, processes, agent) {
        const processBranch = rootTopic.add({ title: 'âš¡ Processes' });
        
        processes.forEach(process => {
            const processTopic = processBranch.add({ 
                title: process.name || process.title || 'Process' 
            });
            
            if (process.description) {
                processTopic.note(process.description);
            }

            // Add complexity indicator
            if (process.complexity) {
                const marker = new Marker();
                if (process.complexity > 7) {
                    processTopic.marker(marker.priority('1')); // High complexity
                } else if (process.complexity > 4) {
                    processTopic.marker(marker.priority('2')); // Medium complexity
                } else {
                    processTopic.marker(marker.priority('3')); // Low complexity
                }
            }
        });
    }

    /**
     * Create generic structure from items array
     */
    async createGenericStructure(rootTopic, items, agent) {
        items.forEach(item => {
            const itemTopic = rootTopic.add({ 
                title: item.title || item.name || 'Item' 
            });
            
            if (item.description) {
                itemTopic.note(item.description);
            }

            // Recursively add children
            if (item.children && Array.isArray(item.children)) {
                this.createGenericStructure(itemTopic, item.children, agent);
            }
        });
    }

    /**
     * Generate logic diagram for codebase analysis results
     */
    async generateCodebaseLogicDiagram(analysisResults, options = {}) {
        const {
            outputPath = './codebase-logic-diagram.xmind',
            title = 'Codebase Logic Analysis',
            agent = 'Leonardo'
        } = options;

        // Transform analysis results into XMind-compatible structure
        const data = {
            decisions: analysisResults.decisions || [],
            flows: analysisResults.flows || [],
            components: analysisResults.files?.map(file => ({
                name: file.name,
                description: `File: ${file.path}`,
                methods: file.functions || [],
                properties: file.variables || []
            })) || [],
            processes: analysisResults.complexProcesses || []
        };

        return await this.generateMindMap({
            title,
            data,
            outputPath,
            agent,
            description: `Logic analysis of codebase with ${analysisResults.summary?.totalFiles || 0} files and ${analysisResults.summary?.totalPatterns || 0} patterns`
        });
    }
}

module.exports = { XMindGeneratorFixed };
