/**
 * Architecture Decision Record (ADR) Manager Module
 * 
 * Handles creation, management, and tracking of architectural decisions
 */

const fs = require('fs').promises;
const path = require('path');

class ADRManager {
  constructor(agent) {
    this.agent = agent;
    this.adrRegistry = [];
    this.nextADRId = 1;
    this.trackingFile = path.join(this.agent.config?.projectRoot || process.cwd(), 'src/agents/architecture_agent/tracking/adr_registry.md');
  }

  async initialize() {
    console.log('🏗️ Initializing ADR Manager...');
    
    // Load existing ADR registry
    await this.loadADRRegistry();
    
    // Ensure tracking directory exists
    const trackingDir = path.dirname(this.trackingFile);
    await fs.mkdir(trackingDir, { recursive: true });
    
    console.log('✅ ADR Manager initialized');
  }

  async loadADRRegistry() {
    try {
      if (await this.fileExists(this.trackingFile)) {
        const content = await fs.readFile(this.trackingFile, 'utf8');
        // Parse existing ADRs from markdown
        this.parseADRRegistry(content);
      }
    } catch (error) {
      console.warn(`⚠️ Could not load ADR registry: ${error.message}`);
    }
  }

  parseADRRegistry(content) {
    // Extract ADR entries from markdown
    const adrMatches = content.match(/## ADR-(\d+):(.*?)(?=## ADR-|\n---|\n$)/gs);
    if (adrMatches) {
      this.adrRegistry = adrMatches.map(match => {
        const idMatch = match.match(/## ADR-(\d+):/);
        const titleMatch = match.match(/## ADR-\d+:\s*(.*)/);
        const statusMatch = match.match(/\*\*Status\*\*:\s*(.*)/);
        const dateMatch = match.match(/\*\*Date\*\*:\s*(.*)/);
        
        return {
          id: idMatch ? parseInt(idMatch[1]) : 0,
          title: titleMatch ? titleMatch[1].trim() : 'Unknown',
          status: statusMatch ? statusMatch[1].trim() : 'Unknown',
          date: dateMatch ? dateMatch[1].trim() : new Date().toISOString(),
          content: match
        };
      });
      
      // Update next ID
      if (this.adrRegistry.length > 0) {
        this.nextADRId = Math.max(...this.adrRegistry.map(adr => adr.id)) + 1;
      }
    }
  }

  generateADRId() {
    return this.nextADRId++;
  }

  async createADR(adrData) {
    const adrId = this.generateADRId();
    const adr = {
      id: adrId,
      title: adrData.title,
      status: adrData.status || 'Proposed',
      date: new Date().toISOString(),
      context: adrData.context,
      decision: adrData.decision,
      consequences: adrData.consequences,
      alternatives: adrData.alternatives || [],
      stakeholders: adrData.stakeholders || []
    };

    // Create ADR document
    const adrDocument = await this.createADRDocument(adr);
    
    // Update registry
    this.adrRegistry.push(adr);
    await this.updateRegistry();
    
    // Update tracking
    await this.updateTracking({
      type: 'adr_created',
      adr: adr,
      timestamp: new Date().toISOString()
    });

    return adr;
  }

  async createADRDocument(adr) {
    const adrContent = this.generateADRContent(adr);
    
    // Save to ADR directory
    const projectRoot = this.agent.config?.projectRoot || process.cwd();
    const adrDir = path.join(projectRoot, 'docs/architecture/adrs');
    await fs.mkdir(adrDir, { recursive: true });
    
    const adrFile = path.join(adrDir, `ADR-${adr.id.toString().padStart(4, '0')}-${this.slugify(adr.title)}.md`);
    await fs.writeFile(adrFile, adrContent);
    
    return adrFile;
  }

  generateADRContent(adr) {
    return `# ADR-${adr.id.toString().padStart(4, '0')}: ${adr.title}

**Status**: ${adr.status}
**Date**: ${new Date(adr.date).toLocaleDateString()}
**Stakeholders**: ${adr.stakeholders.join(', ') || 'Not specified'}

## Context

${adr.context}

## Decision

${adr.decision}

## Consequences

${adr.consequences}

${adr.alternatives && adr.alternatives.length > 0 ? `## Alternatives Considered

${adr.alternatives.map((alt, i) => `### Alternative ${i + 1}: ${alt.title}\n${alt.description}\n**Pros**: ${alt.pros.join(', ')}\n**Cons**: ${alt.cons.join(', ')}`).join('\n\n')}` : ''}

## References

- Architecture Agent Decision: ${adr.date}
- Related ADRs: [To be linked]

---
*This ADR was generated by the Architecture Agent*
`;
  }

  async updateADRStatus(adrId, newStatus, reason) {
    const adr = this.adrRegistry.find(a => a.id === adrId);
    if (!adr) {
      throw new Error(`ADR ${adrId} not found`);
    }

    const oldStatus = adr.status;
    adr.status = newStatus;
    adr.lastModified = new Date().toISOString();
    adr.statusReason = reason;

    await this.updateRegistry();
    
    await this.updateTracking({
      type: 'adr_status_changed',
      adr_id: adrId,
      old_status: oldStatus,
      new_status: newStatus,
      reason: reason,
      timestamp: new Date().toISOString()
    });

    return adr;
  }

  async updateRegistry() {
    const registryContent = this.generateRegistryContent();
    await fs.writeFile(this.trackingFile, registryContent);
  }

  generateRegistryContent() {
    const header = `# Architecture Decision Records Registry

## Overview
This file tracks all Architecture Decision Records (ADRs) created and managed by the Architecture Agent.

## ADR Summary
- **Total ADRs**: ${this.adrRegistry.length}
- **Proposed**: ${this.adrRegistry.filter(a => a.status === 'Proposed').length}
- **Accepted**: ${this.adrRegistry.filter(a => a.status === 'Accepted').length}
- **Rejected**: ${this.adrRegistry.filter(a => a.status === 'Rejected').length}
- **Superseded**: ${this.adrRegistry.filter(a => a.status === 'Superseded').length}

## ADR Entries

`;

    const adrEntries = this.adrRegistry.map(adr => `## ADR-${adr.id.toString().padStart(4, '0')}: ${adr.title}
**Status**: ${adr.status}
**Date**: ${new Date(adr.date).toLocaleDateString()}
**Stakeholders**: ${adr.stakeholders ? adr.stakeholders.join(', ') : 'Not specified'}

${adr.context ? adr.context.substring(0, 200) + (adr.context.length > 200 ? '...' : '') : 'No context provided'}

**Decision**: ${adr.decision ? adr.decision.substring(0, 200) + (adr.decision.length > 200 ? '...' : '') : 'No decision recorded'}

---`).join('\n\n');

    return header + adrEntries + '\n\n---\n*This file is automatically updated by the Architecture Agent ADR Manager module*';
  }

  async getADRsByStatus(status) {
    return this.adrRegistry.filter(adr => adr.status === status);
  }

  async getADRById(id) {
    return this.adrRegistry.find(adr => adr.id === id);
  }

  async searchADRs(query) {
    const lowerQuery = query.toLowerCase();
    return this.adrRegistry.filter(adr => 
      adr.title.toLowerCase().includes(lowerQuery) ||
      (adr.context && adr.context.toLowerCase().includes(lowerQuery)) ||
      (adr.decision && adr.decision.toLowerCase().includes(lowerQuery))
    );
  }

  async updateTracking(result) {
    try {
      const trackingFile = path.join(this.agent.config?.projectRoot || process.cwd(), 'src/agents/architecture_agent/tracking/adr_history.md');
      
      let content = '';
      if (await this.fileExists(trackingFile)) {
        content = await fs.readFile(trackingFile, 'utf8');
      } else {
        content = `# ADR History Tracking

## Recent ADR Activities
*ADR activities will be logged here automatically*

`;
      }

      const timestamp = new Date().toISOString();
      const logEntry = `
## ${timestamp}
**Type**: ${result.type}
**Details**: ${JSON.stringify(result, null, 2)}

`;

      // Insert at the beginning of the activities section
      const insertPoint = content.indexOf('*ADR activities will be logged here automatically*');
      if (insertPoint !== -1) {
        const beforeInsert = content.substring(0, insertPoint + '*ADR activities will be logged here automatically*'.length);
        const afterInsert = content.substring(insertPoint + '*ADR activities will be logged here automatically*'.length);
        content = beforeInsert + logEntry + afterInsert;
      } else {
        content += logEntry;
      }

      await fs.writeFile(trackingFile, content);
    } catch (error) {
      console.warn(`⚠️ Failed to update ADR tracking: ${error.message}`);
    }
  }

  async getStatus() {
    return {
      total_adrs: this.adrRegistry.length,
      by_status: {
        proposed: this.adrRegistry.filter(a => a.status === 'Proposed').length,
        accepted: this.adrRegistry.filter(a => a.status === 'Accepted').length,
        rejected: this.adrRegistry.filter(a => a.status === 'Rejected').length,
        superseded: this.adrRegistry.filter(a => a.status === 'Superseded').length
      },
      recent_adrs: this.adrRegistry
        .sort((a, b) => new Date(b.date) - new Date(a.date))
        .slice(0, 5)
        .map(adr => ({
          id: adr.id,
          title: adr.title,
          status: adr.status,
          date: adr.date
        }))
    };
  }

  slugify(text) {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}

module.exports = ADRManager;
